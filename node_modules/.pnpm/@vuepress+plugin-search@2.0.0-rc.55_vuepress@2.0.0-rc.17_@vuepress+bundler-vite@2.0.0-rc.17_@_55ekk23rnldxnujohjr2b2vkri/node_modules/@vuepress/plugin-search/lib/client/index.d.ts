import * as vue from 'vue';
import { PropType, Ref, ComputedRef } from 'vue';
import { PageData, LocaleConfig } from 'vuepress/shared';

interface HotKeyOptions {
    /**
     * Value of `event.key` to trigger the hot key
     */
    key: string;
    /**
     * Whether to press `event.altKey` at the same time
     *
     * @default false
     */
    alt?: boolean;
    /**
     * Whether to press `event.ctrlKey` at the same time
     *
     * @default false
     */
    ctrl?: boolean;
    /**
     * Whether to press `event.shiftKey` at the same time
     *
     * @default false
     */
    shift?: boolean;
}

interface SearchIndexItem extends Pick<PageData, 'headers' | 'path' | 'title'> {
    pathLocale: string;
    extraFields: string[];
}
type SearchIndex = SearchIndexItem[];

type SearchBoxLocales = LocaleConfig<{
    placeholder: string;
}>;
declare const SearchBox: vue.DefineComponent<vue.ExtractPropTypes<{
    locales: {
        type: PropType<SearchBoxLocales>;
        default: () => {};
    };
    hotKeys: {
        type: PropType<(HotKeyOptions | string)[]>;
        default: () => never[];
    };
    maxSuggestions: {
        type: NumberConstructor;
        default: number;
    };
}>, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>, {}, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.PublicProps, Readonly<vue.ExtractPropTypes<{
    locales: {
        type: PropType<SearchBoxLocales>;
        default: () => {};
    };
    hotKeys: {
        type: PropType<(HotKeyOptions | string)[]>;
        default: () => never[];
    };
    maxSuggestions: {
        type: NumberConstructor;
        default: number;
    };
}>> & Readonly<{}>, {
    locales: SearchBoxLocales;
    hotKeys: (string | HotKeyOptions)[];
    maxSuggestions: number;
}, {}, {}, {}, string, vue.ComponentProvideOptions, true, {}, any>;

declare const useHotKeys: ({ input, hotKeys, }: {
    input: Ref<HTMLInputElement | null>;
    hotKeys: Ref<(HotKeyOptions | string)[]>;
}) => void;

type SearchIndexRef = Ref<SearchIndex>;
declare const searchIndex: any;
declare const useSearchIndex: () => SearchIndexRef;

interface SearchSuggestion {
    link: string;
    title: string;
    header?: string;
}
declare const useSearchSuggestions: ({ searchIndex, routeLocale, query, maxSuggestions, }: {
    searchIndex: Ref<SearchIndex>;
    routeLocale: Ref<string>;
    query: Ref<string>;
    maxSuggestions: Ref<number>;
}) => ComputedRef<SearchSuggestion[]>;

declare const useSuggestionsFocus: (suggestions: Ref<unknown[]>) => {
    focusIndex: Ref<number>;
    focusNext: () => void;
    focusPrev: () => void;
};

/**
 * Determines whether the user is currently focusing a text control.
 * In this case, the search plugin shouldnâ€™t hijack any hotkeys because
 * the user might be typing into a text field, using type-ahead search
 * in a `select` element, etc.
 */
declare const isFocusingTextControl: (target: EventTarget) => boolean;

declare const isKeyMatched: (event: KeyboardEvent, hotKeys: (HotKeyOptions | string)[]) => boolean;

declare const isQueryMatched: (query: string, toMatch: string[]) => boolean;

export { type HotKeyOptions, SearchBox, type SearchBoxLocales, type SearchIndex, type SearchIndexItem, type SearchIndexRef, type SearchSuggestion, isFocusingTextControl, isKeyMatched, isQueryMatched, searchIndex, useHotKeys, useSearchIndex, useSearchSuggestions, useSuggestionsFocus };
